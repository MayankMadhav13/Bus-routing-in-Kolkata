# -*- coding: utf-8 -*-
"""MTP_Clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yBzXQMd3dX7Ry9AFO2QAfJkxFypsEn2V
"""

!pip install docplex
!pip install cplex
!pip install docloud
# link to read clustering https://geoffboeing.com/2014/08/clustering-to-reduce-spatial-data-set-size/

import pandas as pd
from google.colab import files 
uploaded = files.upload()

import io
df2 = pd.read_csv(io.BytesIO(uploaded['Test2_Trim.csv']))

#NS
import pandas as pd, numpy as np, matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
from geopy.distance import great_circle
from shapely.geometry import MultiPoint
#coords = df2.as_matrix(columns=['lat', 'lon'])
#coords = df2.as_matrix(columns=['lat', 'lon'])

coords = df2[["lat", "lon"]].values
#NS

kms_per_radian = 6371.0088
epsilon = 1.4 / kms_per_radian
db = DBSCAN(eps=epsilon, min_samples=1, algorithm='ball_tree', metric='haversine').fit(np.radians(coords))
cluster_labels = db.labels_



num_clusters = len(set(cluster_labels))
clusters = pd.Series([coords[cluster_labels == n] for n in range(num_clusters)])
print('Number of clusters: {}'.format(num_clusters))

#NE
#NS

def get_centermost_point(cluster):
    centroid = (MultiPoint(cluster).centroid.x, MultiPoint(cluster).centroid.y)
    centermost_point = min(cluster, key=lambda point: great_circle(point, centroid).m)
    return tuple(centermost_point)
centermost_points = clusters.map(get_centermost_point)

#NE

#NS
lats, lons = zip(*centermost_points)
rep_points = pd.DataFrame({'lon':lons, 'lat':lats})
#NE

#NS
fig, ax = plt.subplots(figsize=[10, 6])
rs_scatter = ax.scatter(rep_points['lon'], rep_points['lat'], c='#99cc99', edgecolor='None', alpha=0.7, s=120)
df_scatter = ax.scatter(df2['lon'], df2['lat'], c='k', alpha=0.9, s=3)
ax.set_title('Full data set vs K-means reduced set')
ax.set_xlabel('Longitude')
ax.set_ylabel('Latitude')
ax.legend([df_scatter, rs_scatter], ['Full set', 'Reduced set'], loc='upper right')
plt.show()
#NE

#NE

#NS
#import html
#rs = rep_points.apply(lambda row: df[(df['lat']==row['lat']) &amp;&amp; (df['lon']==row['lon'])].iloc[0], axis=1)

#NE

from docplex.mp.model import Model
from docplex.mp.context import Context

url = "https://api-oaas.docloud.ibmcloud.com/job_manager/rest/v1/"
key = "api_616ce9a6-d60e-4c0d-81a6-e91a8b49c261"

import numpy as np
rnd = np.random
rnd.seed(0)
n = 14
Q = 40
N = [i for i in range(1, n+1)]
V = [0] + N
q = {i:rnd.randint(1,4) for i in N}
#loc_x = rnd.rand(len(V))*200
#loc_y = rnd.rand(len(V))*100
#NS
#Change 1: Interchanging lat and long & replacing loc_lat with lat and loc_lng with lon
loc_x =rep_points.lon
  
loc_y = rep_points.lat
#NE

import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=[10, 6])
plt.scatter(loc_x[1:],loc_y[1:], c='k', alpha=0.9, s=8) # Change2: replaced c='b' by  c='k', alpha=0.9, s=8

for i in N:
    plt.annotate('$q_%d=%d$'%(i,q[i]),(loc_x[i]+2,loc_y[i]))
plt.plot(loc_x[0],loc_y[0],c='r', marker = 's')
plt.axis('equal');

A = [(i,j) for i in V for j in V if i!=j]
c = {(i,j):np.hypot(loc_x[i]-loc_x[j],loc_y[i]-loc_y[j]) for i,j in A}
from docplex.mp.model import Model
mdl = Model('CVRP')
x = mdl.binary_var_dict(A, name='x')
u = mdl.continuous_var_dict(N,ub=Q,name='u')
mdl.minimize(mdl.sum(c[i,j]*x[i,j] for i,j in A))
mdl.add_constraints(mdl.sum(x[i,j] for j in V if j!=i)==1 for i in N)
mdl.add_constraints(mdl.sum(x[i,j] for i in V if i!=j)==1 for j in N)
mdl.add_indicator_constraints(mdl.indicator_constraint(x[i,j],u[i]+q[j]==u[j]) for i,j in A if i!=0 and j!=0)
mdl.add_constraints(u[i]>=q[i] for i in N)


solution = mdl.solve(log_output=True)
print(solution)


active_arcs = [a for a in A if x[a].solution_value>0.9]
#plt.scatter(loc_x[1:],loc_y[1:], c='b')
plt.scatter(loc_x[1:],loc_y[1:], c='k', alpha=0.9, s=8)
for i in N:
  plt.annotate('$q_%d=%d$'%(i,q[i]),(loc_x[i]+2,loc_y[i]))
for i,j in active_arcs:
 plt.plot([loc_x[i],loc_x[j]],[loc_y[i],loc_y[j]],c='g', alpha=0.8) 
 
plt.plot(loc_x[0],loc_y[0], c='r', marker = 's')
plt.axis('equal');